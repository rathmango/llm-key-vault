import { z } from "zod";
import { requireUser } from "@/lib/api/auth";
import { getSupabaseAdmin } from "@/lib/supabase/admin";
import { decryptSecret } from "@/lib/crypto";
import { geminiGenerateText, geminiTranscribeYouTubeUrl } from "@/lib/gemini";

export const runtime = "nodejs";
export const maxDuration = 300;

const BodySchema = z.object({
  sessionId: z.string().min(1),
  url: z.string().url(),
  lang: z.string().optional(), // "ko" | "en" etc
  model: z.string().optional(), // gemini model id
  assistantMessageId: z.string().uuid().optional(),
});

type YouTubeVideo = {
  videoId: string;
  url: string;
  title: string | null;
  channelTitle: string | null;
  description: string | null;
  publishedAt: string | null;
  thumbnail: string | null;
  viewCount: number | null;
  duration: string | null;
};

function getYouTubeApiKey(): string | null {
  return process.env.YOUTUBE_DATA_API_KEY ?? process.env.YOUTUBE_API_KEY ?? null;
}

function extractYouTubeId(input: string): string | null {
  const text = input.trim();
  const m1 = text.match(/(?:youtube\.com\/watch\?[^#\s]*\bv=)([a-zA-Z0-9_-]{6,})/i);
  if (m1?.[1]) return m1[1];
  const m2 = text.match(/youtu\.be\/([a-zA-Z0-9_-]{6,})/i);
  if (m2?.[1]) return m2[1];
  const m3 = text.match(/youtube\.com\/shorts\/([a-zA-Z0-9_-]{6,})/i);
  if (m3?.[1]) return m3[1];
  return null;
}

type Transcript = {
  language: string;
  isAutoGenerated: boolean;
  isTruncated: boolean;
  segmentsCount: number;
  textWithTimestamps: string;
};

function msToTimestamp(ms: number): string {
  const totalSec = Math.max(0, Math.floor(ms / 1000));
  const h = Math.floor(totalSec / 3600);
  const m = Math.floor((totalSec % 3600) / 60);
  const s = totalSec % 60;
  if (h > 0) return `${String(h).padStart(2, "0")}:${String(m).padStart(2, "0")}:${String(s).padStart(2, "0")}`;
  return `${String(m).padStart(2, "0")}:${String(s).padStart(2, "0")}`;
}

type Track = { lang: string; kind?: string; name?: string };

function parseTrackListXml(xml: string): Track[] {
  const tracks: Track[] = [];
  const re = /<track\b([^>]*)\/?>/gi;
  let m: RegExpExecArray | null;
  while ((m = re.exec(xml))) {
    const attrs = m[1] ?? "";
    const lang = attrs.match(/\blang_code="([^"]+)"/i)?.[1] ?? attrs.match(/\blang="([^"]+)"/i)?.[1];
    if (!lang) continue;
    const kind = attrs.match(/\bkind="([^"]+)"/i)?.[1];
    const name = attrs.match(/\bname="([^"]*)"/i)?.[1];
    tracks.push({ lang, kind, name });
  }
  return tracks;
}

function pickTrack(tracks: Track[], preferredLang?: string): Track | null {
  if (tracks.length === 0) return null;
  const pref = (preferredLang ?? "").trim().toLowerCase();
  const prefer = [pref, "ko", "en"].filter(Boolean);

  const find = (lang: string, auto: boolean) =>
    tracks.find((t) => t.lang.toLowerCase() === lang && (auto ? t.kind === "asr" : !t.kind));

  for (const lang of prefer) {
    const manual = find(lang, false);
    if (manual) return manual;
    const asr = find(lang, true);
    if (asr) return asr;
  }

  // Fallback: first manual, else first
  return tracks.find((t) => !t.kind) ?? tracks[0] ?? null;
}

type TimedTextJson3 = {
  events?: Array<{
    tStartMs?: number;
    dDurationMs?: number;
    segs?: Array<{ utf8?: string }>;
  }>;
};

async function fetchTimedTextTrackList(videoId: string): Promise<Track[]> {
  const url = new URL("https://www.youtube.com/api/timedtext");
  url.searchParams.set("type", "list");
  url.searchParams.set("v", videoId);
  const res = await fetch(url.toString(), { method: "GET" });
  if (!res.ok) return [];
  const xml = await res.text().catch(() => "");
  if (!xml) return [];
  return parseTrackListXml(xml);
}

async function fetchTimedTextTranscript(videoId: string, preferredLang?: string): Promise<Transcript | null> {
  const tracks = await fetchTimedTextTrackList(videoId);
  const track = pickTrack(tracks, preferredLang);
  if (!track) return null;

  const url = new URL("https://www.youtube.com/api/timedtext");
  url.searchParams.set("fmt", "json3");
  url.searchParams.set("v", videoId);
  url.searchParams.set("lang", track.lang);
  if (track.kind === "asr") url.searchParams.set("kind", "asr");
  if (typeof track.name === "string" && track.name.length > 0) url.searchParams.set("name", track.name);

  const res = await fetch(url.toString(), { method: "GET" });
  if (!res.ok) return null;
  const json = (await res.json().catch(() => null)) as TimedTextJson3 | null;
  const events = Array.isArray(json?.events) ? json!.events! : [];

  const lines: string[] = [];
  let segmentsCount = 0;
  for (const ev of events) {
    const startMs = typeof ev.tStartMs === "number" ? ev.tStartMs : null;
    const segs = Array.isArray(ev.segs) ? ev.segs : [];
    const text = segs
      .map((s) => (typeof s.utf8 === "string" ? s.utf8 : ""))
      .join("")
      .replace(/\s+/g, " ")
      .trim();
    if (!text) continue;
    if (startMs === null) continue;
    segmentsCount += 1;
    lines.push(`[${msToTimestamp(startMs)}] ${text}`);
  }

  const MAX_CHARS = 120_000;
  let textWithTimestamps = lines.join("\n");
  let isTruncated = false;
  if (textWithTimestamps.length > MAX_CHARS) {
    textWithTimestamps = textWithTimestamps.slice(0, MAX_CHARS);
    isTruncated = true;
  }

  return {
    language: track.lang,
    isAutoGenerated: track.kind === "asr",
    isTruncated,
    segmentsCount,
    textWithTimestamps,
  };
}

type RawYouTubeVideoItem = {
  id?: string;
  snippet?: {
    title?: string;
    channelTitle?: string;
    description?: string;
    publishedAt?: string;
    thumbnails?: {
      default?: { url?: string };
      medium?: { url?: string };
      high?: { url?: string };
      standard?: { url?: string };
      maxres?: { url?: string };
    };
  };
  statistics?: { viewCount?: string };
  contentDetails?: { duration?: string };
};

function parseVideo(item: RawYouTubeVideoItem, videoId: string): YouTubeVideo {
  const snippet = item.snippet ?? {};
  const thumbnails = snippet.thumbnails ?? {};
  const thumbCandidates = [
    thumbnails.maxres?.url,
    thumbnails.standard?.url,
    thumbnails.high?.url,
    thumbnails.medium?.url,
    thumbnails.default?.url,
  ].filter((v): v is string => typeof v === "string");

  const viewCountRaw = item.statistics?.viewCount;
  const viewCount = typeof viewCountRaw === "string" ? Number(viewCountRaw) : null;

  return {
    videoId,
    url: `https://www.youtube.com/watch?v=${encodeURIComponent(videoId)}`,
    title: typeof snippet.title === "string" ? snippet.title : null,
    channelTitle: typeof snippet.channelTitle === "string" ? snippet.channelTitle : null,
    description: typeof snippet.description === "string" ? snippet.description : null,
    publishedAt: typeof snippet.publishedAt === "string" ? snippet.publishedAt : null,
    thumbnail: thumbCandidates[0] ?? null,
    viewCount: Number.isFinite(viewCount) ? viewCount : null,
    duration: typeof item.contentDetails?.duration === "string" ? item.contentDetails.duration : null,
  };
}

async function fetchVideoMeta(apiKey: string, videoId: string): Promise<YouTubeVideo> {
  const url = new URL("https://www.googleapis.com/youtube/v3/videos");
  url.searchParams.set("part", "snippet,statistics,contentDetails");
  url.searchParams.set("id", videoId);
  url.searchParams.set("key", apiKey);

  const res = await fetch(url.toString(), { method: "GET" });
  const json = await res.json().catch(() => ({}));
  if (!res.ok) {
    const msg = typeof json?.error?.message === "string" ? json.error.message : `YouTube API error (${res.status})`;
    throw new Error(msg);
  }
  const item = Array.isArray(json?.items) ? (json.items[0] as RawYouTubeVideoItem | undefined) : undefined;
  return parseVideo(item ?? {}, videoId);
}

async function loadGeminiKey(userId: string): Promise<string | null> {
  const supabase = getSupabaseAdmin();
  const { data, error } = await supabase
    .from("api_keys")
    .select("encrypted_key")
    .eq("user_id", userId)
    .eq("provider", "gemini")
    .maybeSingle();
  if (error) return null;
  if (!data?.encrypted_key) return null;
  try {
    return decryptSecret(data.encrypted_key);
  } catch {
    return null;
  }
}

function takeSection(all: string, header: string): string {
  const re = new RegExp(`^###\\s+${header}\\s*$`, "mi");
  const idx = all.search(re);
  if (idx < 0) return "";
  const rest = all.slice(idx);
  const after = rest.replace(re, "").replace(/^\r?\n/, "");
  const next = after.search(/^###\s+/m);
  return (next >= 0 ? after.slice(0, next) : after).trim();
}

function sanitizeTranscript(text: string): { text: string; isTruncated: boolean; segmentsCount: number } {
  const MAX_CHARS = 160_000;
  let out = text.trim();
  let isTruncated = false;
  if (out.length > MAX_CHARS) {
    out = out.slice(0, MAX_CHARS);
    isTruncated = true;
  }
  const segmentsCount = out
    .split("\n")
    .map((x) => x.trim())
    .filter((x) => /^\[\d{2}:\d{2}\]/.test(x) || /^\[\d{2}:\d{2}:\d{2}\]/.test(x))
    .length;
  return { text: out, isTruncated, segmentsCount };
}

function sampleTranscriptForAnalysis(text: string): string {
  const t = text.trim();
  const MAX_CHARS = 30_000; // keep requests small/robust
  if (t.length <= MAX_CHARS) return t;

  const part = Math.floor(MAX_CHARS / 3);
  const start = t.slice(0, part);
  const midStart = Math.max(0, Math.floor(t.length / 2) - Math.floor(part / 2));
  const mid = t.slice(midStart, midStart + part);
  const end = t.slice(-part);
  return `${start}\n...\n${mid}\n...\n${end}`;
}

function buildAnalysisMarkdown(args: {
  video: YouTubeVideo;
  summaryMd: string;
  outlineMd: string;
  questionsMd: string;
  transcriptSaved: boolean;
  transcriptSource: string;
  transcriptTruncated: boolean;
}): string {
  // Deprecated for user-visible output. Keep as utility if needed later.
  const lines: string[] = [];
  lines.push(`üì∫ ${args.video.title ?? "YouTube ÏòÅÏÉÅ"} Î∂ÑÏÑù ÏôÑÎ£å`);
  if (args.transcriptSaved) {
    lines.push(`(transcript: ${args.transcriptSource}${args.transcriptTruncated ? ", truncated" : ""})`);
  } else {
    lines.push("(transcript: not available)");
  }
  return lines.join("\n");
}

// SSE helper
function sseEvent(type: string, data: unknown): string {
  return `data: ${JSON.stringify({ type, ...((typeof data === "object" && data !== null) ? data : { value: data }) })}\n\n`;
}

export async function POST(request: Request) {
  const encoder = new TextEncoder();

  // Stream for progress updates
  const stream = new TransformStream();
  const writer = stream.writable.getWriter();
  let streamClosed = false;

  const safeWrite = async (chunk: Uint8Array) => {
    if (streamClosed) return;
    try {
      await writer.write(chunk);
    } catch {
      streamClosed = true;
    }
  };

  const closeStream = async () => {
    if (streamClosed) return;
    try {
      await writer.close();
    } catch {
      // ignore
    } finally {
      streamClosed = true;
    }
  };

  const send = async (type: string, data: unknown) => {
    await safeWrite(encoder.encode(sseEvent(type, data)));
  };

  const sendError = async (message: string) => {
    await send("error", { error: message });
    await closeStream();
  };

  // Start processing in background
  (async () => {
    try {
      const user = await requireUser(request);
      const body = BodySchema.parse(await request.json());

      const videoId = extractYouTubeId(body.url);
      if (!videoId) {
        await sendError("Invalid YouTube URL");
        return;
      }

      const supabase = getSupabaseAdmin();

      // Verify session ownership
      const { data: session } = await supabase
        .from("chat_sessions")
        .select("id")
        .eq("id", body.sessionId)
        .eq("user_id", user.id)
        .single();

      if (!session) {
        await sendError("Session not found");
        return;
      }

      const assistantMessageId = body.assistantMessageId ?? null;
      const updateAssistant = async (content: string) => {
        if (!assistantMessageId) return;
        try {
          await supabase
            .from("chat_messages")
            .upsert(
              {
                id: assistantMessageId,
                session_id: body.sessionId,
                role: "assistant",
                content,
              },
              { onConflict: "id" }
            );
          // Touch session updated_at (so sidebar ordering reflects progress)
          await supabase
            .from("chat_sessions")
            .update({ updated_at: new Date().toISOString() })
            .eq("id", body.sessionId);
        } catch {
          // ignore DB failures (streaming still works)
        }
      };

      // Fast path: already ingested in this session
      try {
        const { data: existing } = await supabase
          .from("video_contexts")
          .select(
            "id,user_id,session_id,provider,video_id,url,title,channel_title,description,transcript_language,transcript_source,transcript_text,summary_md,outline_md,questions_md,created_at,updated_at"
          )
          .eq("user_id", user.id)
          .eq("session_id", body.sessionId)
          .eq("video_id", videoId)
          .maybeSingle();

        if (existing && typeof existing.url === "string") {
          const video: YouTubeVideo = {
            videoId,
            url: existing.url,
            title: typeof existing.title === "string" ? existing.title : null,
            channelTitle: typeof existing.channel_title === "string" ? existing.channel_title : null,
            description: typeof existing.description === "string" ? existing.description : null,
            publishedAt: null,
            thumbnail: null,
            viewCount: null,
            duration: null,
          };

          const transcriptText = typeof existing.transcript_text === "string" ? existing.transcript_text : "";
          const transcriptSanitized = sanitizeTranscript(transcriptText);
          const transcriptSource =
            typeof existing.transcript_source === "string" && existing.transcript_source.trim()
              ? existing.transcript_source
              : transcriptText
                ? "cached"
                : "pending";

          const title = video.title ?? "YouTube ÏòÅÏÉÅ";
          const channel = video.channelTitle ?? "";
          const summary = typeof existing.summary_md === "string" ? existing.summary_md.trim() : "";

          const openerText = [
            `## üì∫ ${title}`,
            channel ? `- Ï±ÑÎÑê: **${channel}**` : null,
            `- ÎßÅÌÅ¨: ${video.url}`,
            "",
            summary ? "Ïù¥ ÏòÅÏÉÅÏùÄ(Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ Í∏∞Ï§Ä) ÎåÄÎûµ Ïù¥Îü∞ ÎÇ¥Ïö©ÏùÑ Îã§Î£®Îäî Í≤É Í∞ôÏïÑ:" : "Ïù¥ ÏòÅÏÉÅÏùÄ Ïñ¥Îñ§ ÎÇ¥Ïö©ÏùºÍπå?",
            summary ? summary : "",
            "",
            "ÏßÄÍ∏à Î≠êÍ∞Ä Ï†úÏùº Í∂ÅÍ∏àÌï¥?",
          ]
            .filter(Boolean)
            .join("\n");

          await send("metadata", { video });
          await send("opener", { text: openerText });
          await send("complete", {
            ready: Boolean(transcriptSanitized.text),
            transcriptSource,
          });
          await closeStream();
          return;
        }
      } catch {
        // ignore and continue
      }

      const ytKey = getYouTubeApiKey();
      if (!ytKey) {
        await sendError("Missing YOUTUBE_DATA_API_KEY");
        return;
      }

      const geminiKey = await loadGeminiKey(user.id);

      const lang = (body.lang ?? "ko").trim() || "ko";
      const geminiModel = body.model ?? "gemini-2.5-flash";

      // Step 1: Fetch metadata
      await send("progress", { step: 1, total: 3, message: "üîç ÏòÅÏÉÅ Ï†ïÎ≥¥ Í∞ÄÏ†∏Ïò§Îäî Ï§ë‚Ä¶" });
      await updateAssistant("üîç ÏòÅÏÉÅ Ï†ïÎ≥¥ Í∞ÄÏ†∏Ïò§Îäî Ï§ë‚Ä¶");
      const video = await fetchVideoMeta(ytKey, videoId);

      // Send video metadata early so UI can show title
      await send("metadata", { video });

      // Create a lightweight video_contexts row early so chat can know ‚Äúanalysis in progress‚Äù
      try {
        await supabase
          .from("video_contexts")
          .upsert(
            {
              user_id: user.id,
              session_id: body.sessionId,
              provider: "gemini",
              video_id: videoId,
              url: video.url,
              title: video.title,
              channel_title: video.channelTitle,
              description: video.description,
              transcript_language: lang,
              transcript_source: "pending",
            },
            { onConflict: "session_id,video_id", ignoreDuplicates: true }
          );
      } catch {
        // ignore
      }

      // Fast UX: generate a metadata-based opener + quick summary (text-only) in parallel.
      void (async () => {
        try {
          // If user didn't set Gemini key, just skip this helper; we still proceed with captions-based transcript.
          if (!geminiKey) return;
          const desc = (video.description ?? "").trim();
          const title = (video.title ?? "").trim();
          const channel = (video.channelTitle ?? "").trim();

          const metaPrompt = [
            "You are a helpful assistant.",
            "",
            "You are given ONLY YouTube metadata (title/channel/description).",
            "Infer what the video is likely about and start a conversation.",
            "",
            "Return EXACTLY two sections in this order:",
            "### OPENER",
            "### META_SUMMARY",
            "",
            "Rules:",
            "- OPENER: 2‚Äì4 sentences in Korean. Paraphrase; DO NOT quote the description verbatim. Sound like you understood the video.",
            "- OPENER must end with ONE question asking what the user is curious about.",
            "- META_SUMMARY: 6‚Äì10 bullet points (Korean) summarizing what the video likely covers, grounded in metadata. No disclaimers about metadata.",
            "- Keep it concise.",
            "",
            "Metadata:",
            `Title: ${title || "(none)"}`,
            `Channel: ${channel || "(none)"}`,
            `Description: ${(desc || "(none)").slice(0, 2000)}`,
          ].join("\n");

          const metaCombined = await geminiGenerateText({
            apiKey: geminiKey,
            model: geminiModel,
            contents: [{ role: "user", parts: [{ text: metaPrompt }] }],
          });

          const opener = takeSection(metaCombined, "OPENER") || metaCombined.trim();
          const metaSummary = takeSection(metaCombined, "META_SUMMARY");

          if (opener.trim()) {
            const openerText = [
              `## üì∫ ${title || "YouTube ÏòÅÏÉÅ"}`,
              channel ? `- Ï±ÑÎÑê: **${channel}**` : null,
              `- ÎßÅÌÅ¨: ${video.url}`,
              "",
              opener.trim(),
              "",
              metaSummary.trim() ? "Ïù¥ ÏòÅÏÉÅÏùÄ(Ï†úÎ™©/ÏÑ§Î™Ö Í∏∞Ï§Ä) ÎåÄÎûµ Ïù¥Îü∞ ÎÇ¥Ïö©ÏùÑ Îã¥Í≥† ÏûàÏñ¥:" : null,
              metaSummary.trim() ? metaSummary.trim() : null,
            ]
              .filter(Boolean)
              .join("\n");
            await send("opener", { text: openerText });
          }

          if (metaSummary.trim()) {
            await supabase
              .from("video_contexts")
              .upsert(
                {
                  user_id: user.id,
                  session_id: body.sessionId,
                  provider: "gemini",
                  video_id: videoId,
                  url: video.url,
                  title: video.title,
                  channel_title: video.channelTitle,
                  description: video.description,
                  transcript_language: lang,
                  transcript_source: "pending",
                  summary_md: metaSummary.trim(),
                },
                { onConflict: "session_id,video_id" }
              );
          }
        } catch {
          // ignore opener failures
        }
      })();

      // Step 2: Transcript acquisition (fast path: YouTube timedtext captions)
      await send("progress", { step: 2, total: 3, message: "üìù ÏûêÎßâ(Ï∫°ÏÖò) ÌôïÏù∏ Ï§ë‚Ä¶" });
      await updateAssistant("üìù ÏûêÎßâ(Ï∫°ÏÖò) ÌôïÏù∏ Ï§ë‚Ä¶");

      let transcriptText = "";
      let transcriptLanguage = lang;
      let transcriptSource = "";
      let transcriptIsTruncated = false;
      let transcriptSegmentsCount = 0;

      const timed = await fetchTimedTextTranscript(videoId, lang).catch(() => null);
      if (timed && typeof timed.textWithTimestamps === "string" && timed.textWithTimestamps.trim()) {
        transcriptText = timed.textWithTimestamps;
        transcriptLanguage = timed.language;
        transcriptSource = timed.isAutoGenerated ? "timedtext-asr" : "timedtext";
        transcriptIsTruncated = timed.isTruncated;
        transcriptSegmentsCount = timed.segmentsCount;

        // Persist transcript early so follow-up questions can use it even before summary is ready
        try {
          await supabase
            .from("video_contexts")
            .upsert(
              {
                user_id: user.id,
                session_id: body.sessionId,
                provider: "gemini",
                video_id: videoId,
                url: video.url,
                title: video.title,
                channel_title: video.channelTitle,
                description: video.description,
                transcript_language: transcriptLanguage,
                transcript_source: transcriptSource,
                transcript_text: transcriptText,
              },
              { onConflict: "session_id,video_id" }
            );
        } catch {
          // ignore
        }
      } else {
        // Fallback: no captions ‚Äî use Gemini video transcription (slow). If Gemini key isn't set, we still complete with metadata only.
        transcriptSource = "gemini";
        await send("progress", { step: 2, total: 3, message: "üéß ÏûêÎßâ ÏóÜÏùå ‚Üí ÏùåÏÑ± Ï†ÑÏÇ¨ Ï§ë‚Ä¶ (ÏãúÍ∞ÑÏù¥ Í±∏Î¶¥ Ïàò ÏûàÏñ¥Ïöî)" });
        await updateAssistant("üéß ÏûêÎßâ ÏóÜÏùå ‚Üí ÏùåÏÑ± Ï†ÑÏÇ¨ Ï§ë‚Ä¶");

        if (geminiKey) {
          try {
            const tr = await geminiTranscribeYouTubeUrl({
              apiKey: geminiKey,
              youtubeUrl: video.url,
              languageHint: lang,
              model: geminiModel,
            });
            const transcriptSanitized = sanitizeTranscript(tr.textWithTimestamps);
            transcriptText = transcriptSanitized.text;
            transcriptIsTruncated = transcriptSanitized.isTruncated;
            transcriptSegmentsCount = transcriptSanitized.segmentsCount;
            transcriptLanguage = tr.language;
            transcriptSource = "gemini";
          } catch {
            transcriptSource = "failed";
            transcriptText = "";
          }
        } else {
          transcriptSource = "failed";
        }

        // Persist whatever we have (maybe empty)
        try {
          await supabase
            .from("video_contexts")
            .upsert(
              {
                user_id: user.id,
                session_id: body.sessionId,
                provider: "gemini",
                video_id: videoId,
                url: video.url,
                title: video.title,
                channel_title: video.channelTitle,
                description: video.description,
                transcript_language: transcriptLanguage,
                transcript_source: transcriptSource,
                transcript_text: transcriptText,
              },
              { onConflict: "session_id,video_id" }
            );
        } catch {
          // ignore
        }
      }

      await send("progress", { step: 3, total: 3, message: "‚úÖ Ï§ÄÎπÑ ÏôÑÎ£å" });
      await updateAssistant("‚úÖ ÏòÅÏÉÅ Î∂ÑÏÑù Ï§ÄÎπÑ ÏôÑÎ£å");

      // Final result (do NOT send long report to the chat UI)
      await send("complete", {
        ready: Boolean(transcriptText),
        transcriptSource: transcriptSource || "unknown",
        transcriptTruncated: transcriptIsTruncated,
        transcriptSegments: transcriptSegmentsCount,
      });

      await closeStream();
    } catch (e) {
      const message = e instanceof Error ? e.message : "Unexpected error";
      try {
        await sendError(message);
      } catch {
        // Writer might already be closed
      }
    }
  })();

  return new Response(stream.readable, {
    headers: {
      "Content-Type": "text/event-stream",
      "Cache-Control": "no-cache",
      Connection: "keep-alive",
    },
  });
}
