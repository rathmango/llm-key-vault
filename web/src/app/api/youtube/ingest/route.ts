import { z } from "zod";
import { requireUser } from "@/lib/api/auth";
import { getSupabaseAdmin } from "@/lib/supabase/admin";
import { decryptSecret } from "@/lib/crypto";
import { geminiGenerateText } from "@/lib/gemini";

export const runtime = "nodejs";
export const maxDuration = 300;

const BodySchema = z.object({
  sessionId: z.string().min(1),
  url: z.string().url(),
  lang: z.string().optional(), // "ko" | "en" etc
  model: z.string().optional(), // gemini model id
  assistantMessageId: z.string().uuid().optional(),
});

type YouTubeVideo = {
  videoId: string;
  url: string;
  title: string | null;
  channelTitle: string | null;
  description: string | null;
  publishedAt: string | null;
  thumbnail: string | null;
  viewCount: number | null;
  duration: string | null;
};

function getYouTubeApiKey(): string | null {
  return process.env.YOUTUBE_DATA_API_KEY ?? process.env.YOUTUBE_API_KEY ?? null;
}

function extractYouTubeId(input: string): string | null {
  const text = input.trim();
  const m1 = text.match(/(?:youtube\.com\/watch\?[^#\s]*\bv=)([a-zA-Z0-9_-]{6,})/i);
  if (m1?.[1]) return m1[1];
  const m2 = text.match(/youtu\.be\/([a-zA-Z0-9_-]{6,})/i);
  if (m2?.[1]) return m2[1];
  const m3 = text.match(/youtube\.com\/shorts\/([a-zA-Z0-9_-]{6,})/i);
  if (m3?.[1]) return m3[1];
  return null;
}

type Transcript = {
  language: string;
  isAutoGenerated: boolean;
  isTruncated: boolean;
  segmentsCount: number;
  textWithTimestamps: string;
};

function msToTimestamp(ms: number): string {
  const totalSec = Math.max(0, Math.floor(ms / 1000));
  const h = Math.floor(totalSec / 3600);
  const m = Math.floor((totalSec % 3600) / 60);
  const s = totalSec % 60;
  if (h > 0) return `${String(h).padStart(2, "0")}:${String(m).padStart(2, "0")}:${String(s).padStart(2, "0")}`;
  return `${String(m).padStart(2, "0")}:${String(s).padStart(2, "0")}`;
}

type Track = { lang: string; kind?: string; name?: string };

function parseTrackListXml(xml: string): Track[] {
  const tracks: Track[] = [];
  const re = /<track\b([^>]*)\/?>/gi;
  let m: RegExpExecArray | null;
  while ((m = re.exec(xml))) {
    const attrs = m[1] ?? "";
    const lang = attrs.match(/\blang_code="([^"]+)"/i)?.[1] ?? attrs.match(/\blang="([^"]+)"/i)?.[1];
    if (!lang) continue;
    const kind = attrs.match(/\bkind="([^"]+)"/i)?.[1];
    const name = attrs.match(/\bname="([^"]*)"/i)?.[1];
    tracks.push({ lang, kind, name });
  }
  return tracks;
}

function pickTrack(tracks: Track[], preferredLang?: string): Track | null {
  if (tracks.length === 0) return null;
  const pref = (preferredLang ?? "").trim().toLowerCase();
  const prefer = [pref, "ko", "en"].filter(Boolean);

  const find = (lang: string, auto: boolean) =>
    tracks.find((t) => t.lang.toLowerCase() === lang && (auto ? t.kind === "asr" : !t.kind));

  for (const lang of prefer) {
    const manual = find(lang, false);
    if (manual) return manual;
    const asr = find(lang, true);
    if (asr) return asr;
  }

  // Fallback: first manual, else first
  return tracks.find((t) => !t.kind) ?? tracks[0] ?? null;
}

type TimedTextJson3 = {
  events?: Array<{
    tStartMs?: number;
    dDurationMs?: number;
    segs?: Array<{ utf8?: string }>;
  }>;
};

async function fetchTimedTextTrackList(videoId: string): Promise<Track[]> {
  const url = new URL("https://www.youtube.com/api/timedtext");
  url.searchParams.set("type", "list");
  url.searchParams.set("v", videoId);
  const res = await fetch(url.toString(), { method: "GET" });
  if (!res.ok) return [];
  const xml = await res.text().catch(() => "");
  if (!xml) return [];
  return parseTrackListXml(xml);
}

async function fetchTimedTextTranscript(videoId: string, preferredLang?: string): Promise<Transcript | null> {
  const tracks = await fetchTimedTextTrackList(videoId);
  const track = pickTrack(tracks, preferredLang);
  if (!track) return null;

  const url = new URL("https://www.youtube.com/api/timedtext");
  url.searchParams.set("fmt", "json3");
  url.searchParams.set("v", videoId);
  url.searchParams.set("lang", track.lang);
  if (track.kind === "asr") url.searchParams.set("kind", "asr");
  if (typeof track.name === "string" && track.name.length > 0) url.searchParams.set("name", track.name);

  const res = await fetch(url.toString(), { method: "GET" });
  if (!res.ok) return null;
  const json = (await res.json().catch(() => null)) as TimedTextJson3 | null;
  const events = Array.isArray(json?.events) ? json!.events! : [];

  const lines: string[] = [];
  let segmentsCount = 0;
  for (const ev of events) {
    const startMs = typeof ev.tStartMs === "number" ? ev.tStartMs : null;
    const segs = Array.isArray(ev.segs) ? ev.segs : [];
    const text = segs
      .map((s) => (typeof s.utf8 === "string" ? s.utf8 : ""))
      .join("")
      .replace(/\s+/g, " ")
      .trim();
    if (!text) continue;
    if (startMs === null) continue;
    segmentsCount += 1;
    lines.push(`[${msToTimestamp(startMs)}] ${text}`);
  }

  const MAX_CHARS = 120_000;
  let textWithTimestamps = lines.join("\n");
  let isTruncated = false;
  if (textWithTimestamps.length > MAX_CHARS) {
    textWithTimestamps = textWithTimestamps.slice(0, MAX_CHARS);
    isTruncated = true;
  }

  return {
    language: track.lang,
    isAutoGenerated: track.kind === "asr",
    isTruncated,
    segmentsCount,
    textWithTimestamps,
  };
}

type RawYouTubeVideoItem = {
  id?: string;
  snippet?: {
    title?: string;
    channelTitle?: string;
    description?: string;
    publishedAt?: string;
    thumbnails?: {
      default?: { url?: string };
      medium?: { url?: string };
      high?: { url?: string };
      standard?: { url?: string };
      maxres?: { url?: string };
    };
  };
  statistics?: { viewCount?: string };
  contentDetails?: { duration?: string };
};

function parseVideo(item: RawYouTubeVideoItem, videoId: string): YouTubeVideo {
  const snippet = item.snippet ?? {};
  const thumbnails = snippet.thumbnails ?? {};
  const thumbCandidates = [
    thumbnails.maxres?.url,
    thumbnails.standard?.url,
    thumbnails.high?.url,
    thumbnails.medium?.url,
    thumbnails.default?.url,
  ].filter((v): v is string => typeof v === "string");

  const viewCountRaw = item.statistics?.viewCount;
  const viewCount = typeof viewCountRaw === "string" ? Number(viewCountRaw) : null;

  return {
    videoId,
    url: `https://www.youtube.com/watch?v=${encodeURIComponent(videoId)}`,
    title: typeof snippet.title === "string" ? snippet.title : null,
    channelTitle: typeof snippet.channelTitle === "string" ? snippet.channelTitle : null,
    description: typeof snippet.description === "string" ? snippet.description : null,
    publishedAt: typeof snippet.publishedAt === "string" ? snippet.publishedAt : null,
    thumbnail: thumbCandidates[0] ?? null,
    viewCount: Number.isFinite(viewCount) ? viewCount : null,
    duration: typeof item.contentDetails?.duration === "string" ? item.contentDetails.duration : null,
  };
}

async function fetchVideoMeta(apiKey: string, videoId: string): Promise<YouTubeVideo> {
  const url = new URL("https://www.googleapis.com/youtube/v3/videos");
  url.searchParams.set("part", "snippet,statistics,contentDetails");
  url.searchParams.set("id", videoId);
  url.searchParams.set("key", apiKey);

  const res = await fetch(url.toString(), { method: "GET" });
  const json = await res.json().catch(() => ({}));
  if (!res.ok) {
    const msg = typeof json?.error?.message === "string" ? json.error.message : `YouTube API error (${res.status})`;
    throw new Error(msg);
  }
  const item = Array.isArray(json?.items) ? (json.items[0] as RawYouTubeVideoItem | undefined) : undefined;
  return parseVideo(item ?? {}, videoId);
}

async function loadGeminiKey(userId: string): Promise<string | null> {
  const supabase = getSupabaseAdmin();
  const { data, error } = await supabase
    .from("api_keys")
    .select("encrypted_key")
    .eq("user_id", userId)
    .eq("provider", "gemini")
    .maybeSingle();
  if (error) return null;
  if (!data?.encrypted_key) return null;
  try {
    return decryptSecret(data.encrypted_key);
  } catch {
    return null;
  }
}

function takeSection(all: string, header: string): string {
  const re = new RegExp(`^###\\s+${header}\\s*$`, "mi");
  const idx = all.search(re);
  if (idx < 0) return "";
  const rest = all.slice(idx);
  const after = rest.replace(re, "").replace(/^\r?\n/, "");
  const next = after.search(/^###\s+/m);
  return (next >= 0 ? after.slice(0, next) : after).trim();
}

function sanitizeTranscript(text: string): { text: string; isTruncated: boolean; segmentsCount: number } {
  const MAX_CHARS = 160_000;
  let out = text.trim();
  let isTruncated = false;
  if (out.length > MAX_CHARS) {
    out = out.slice(0, MAX_CHARS);
    isTruncated = true;
  }
  const segmentsCount = out
    .split("\n")
    .map((x) => x.trim())
    .filter((x) => /^\[\d{2}:\d{2}\]/.test(x) || /^\[\d{2}:\d{2}:\d{2}\]/.test(x))
    .length;
  return { text: out, isTruncated, segmentsCount };
}

function buildAnalysisMarkdown(args: {
  video: YouTubeVideo;
  summaryMd: string;
  outlineMd: string;
  questionsMd: string;
  transcriptSaved: boolean;
  transcriptSource: string;
  transcriptTruncated: boolean;
}): string {
  const lines: string[] = [];
  lines.push(`## ğŸ“º ${args.video.title ?? "YouTube ì˜ìƒ"}`);
  if (args.video.channelTitle) lines.push(`- ì±„ë„: **${args.video.channelTitle}**`);
  lines.push(`- ë§í¬: ${args.video.url}`);
  lines.push("");
  lines.push("## ìš”ì•½");
  lines.push(args.summaryMd || "- (ìš”ì•½ ìƒì„± ì‹¤íŒ¨)");
  lines.push("");
  lines.push("## íƒ€ì„ìŠ¤íƒ¬í”„ ì•„ì›ƒë¼ì¸");
  lines.push(args.outlineMd || "- (ì•„ì›ƒë¼ì¸ ìƒì„± ì‹¤íŒ¨)");
  lines.push("");
  lines.push("## ë‹¤ìŒ ì§ˆë¬¸ ì¶”ì²œ");
  lines.push(args.questionsMd || "- (ì§ˆë¬¸ ì¶”ì²œ ìƒì„± ì‹¤íŒ¨)");
  lines.push("");
  if (args.transcriptSaved) {
    lines.push(
      `> ì „ë¬¸(íŠ¸ëœìŠ¤í¬ë¦½íŠ¸)ì€ **DBì— ì €ì¥**ë˜ì—ˆìŠµë‹ˆë‹¤. (source: \`${args.transcriptSource}\`${args.transcriptTruncated ? ", truncated" : ""})`
    );
  } else {
    lines.push("> ì „ë¬¸(íŠ¸ëœìŠ¤í¬ë¦½íŠ¸)ì„ ì €ì¥í•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤. (Gemini í‚¤ ì„¤ì • í•„ìš”)");
  }
  return lines.join("\n");
}

// SSE helper
function sseEvent(type: string, data: unknown): string {
  return `data: ${JSON.stringify({ type, ...((typeof data === "object" && data !== null) ? data : { value: data }) })}\n\n`;
}

export async function POST(request: Request) {
  const encoder = new TextEncoder();

  // Stream for progress updates
  const stream = new TransformStream();
  const writer = stream.writable.getWriter();

  const send = async (type: string, data: unknown) => {
    await writer.write(encoder.encode(sseEvent(type, data)));
  };

  const sendError = async (message: string) => {
    await send("error", { error: message });
    await writer.close();
  };

  // Start processing in background
  (async () => {
    try {
      const user = await requireUser(request);
      const body = BodySchema.parse(await request.json());

      const videoId = extractYouTubeId(body.url);
      if (!videoId) {
        await sendError("Invalid YouTube URL");
        return;
      }

      const supabase = getSupabaseAdmin();

      // Verify session ownership
      const { data: session } = await supabase
        .from("chat_sessions")
        .select("id")
        .eq("id", body.sessionId)
        .eq("user_id", user.id)
        .single();

      if (!session) {
        await sendError("Session not found");
        return;
      }

      const assistantMessageId = body.assistantMessageId ?? null;
      const updateAssistant = async (content: string) => {
        if (!assistantMessageId) return;
        try {
          await supabase
            .from("chat_messages")
            .upsert(
              {
                id: assistantMessageId,
                session_id: body.sessionId,
                role: "assistant",
                content,
              },
              { onConflict: "id" }
            );
          // Touch session updated_at (so sidebar ordering reflects progress)
          await supabase
            .from("chat_sessions")
            .update({ updated_at: new Date().toISOString() })
            .eq("id", body.sessionId);
        } catch {
          // ignore DB failures (streaming still works)
        }
      };

      // Fast path: already ingested in this session
      try {
        const { data: existing } = await supabase
          .from("video_contexts")
          .select(
            "id,user_id,session_id,provider,video_id,url,title,channel_title,description,transcript_language,transcript_source,transcript_text,summary_md,outline_md,questions_md,created_at,updated_at"
          )
          .eq("user_id", user.id)
          .eq("session_id", body.sessionId)
          .eq("video_id", videoId)
          .maybeSingle();

        if (
          existing &&
          typeof existing.url === "string" &&
          typeof existing.summary_md === "string" &&
          typeof existing.outline_md === "string" &&
          typeof existing.questions_md === "string"
        ) {
          const video: YouTubeVideo = {
            videoId,
            url: existing.url,
            title: typeof existing.title === "string" ? existing.title : null,
            channelTitle: typeof existing.channel_title === "string" ? existing.channel_title : null,
            description: typeof existing.description === "string" ? existing.description : null,
            publishedAt: null,
            thumbnail: null,
            viewCount: null,
            duration: null,
          };

          const transcriptText = typeof existing.transcript_text === "string" ? existing.transcript_text : "";
          const transcriptSanitized = sanitizeTranscript(transcriptText);
          const transcriptSource = typeof existing.transcript_source === "string" ? existing.transcript_source : "cached";

          const assistantMarkdown = buildAnalysisMarkdown({
            video,
            summaryMd: existing.summary_md,
            outlineMd: existing.outline_md,
            questionsMd: existing.questions_md,
            transcriptSaved: Boolean(transcriptSanitized.text),
            transcriptSource,
            transcriptTruncated: transcriptSanitized.isTruncated,
          });

          await send("metadata", { video });
          await updateAssistant(assistantMarkdown);
          await send("complete", {
            context: existing,
            video,
            analysis: {
              markdown: assistantMarkdown,
              transcriptTruncated: transcriptSanitized.isTruncated,
              transcriptSegments: transcriptSanitized.segmentsCount,
            },
          });
          await writer.close();
          return;
        }
      } catch {
        // ignore and continue
      }

      const ytKey = getYouTubeApiKey();
      if (!ytKey) {
        await sendError("Missing YOUTUBE_DATA_API_KEY");
        return;
      }

      const geminiKey = await loadGeminiKey(user.id);
      if (!geminiKey) {
        await sendError("Gemini API key not set. Save it in API Key íƒ­ (Gemini).");
        return;
      }

      const lang = (body.lang ?? "ko").trim() || "ko";
      const geminiModel = body.model ?? "gemini-2.5-flash";

      // Step 1: Fetch metadata
      await send("progress", { step: 1, total: 4, message: "ğŸ” ì˜ìƒ ì •ë³´ ê°€ì ¸ì˜¤ëŠ” ì¤‘â€¦" });
      await updateAssistant("ğŸ” ì˜ìƒ ì •ë³´ ê°€ì ¸ì˜¤ëŠ” ì¤‘â€¦");
      const video = await fetchVideoMeta(ytKey, videoId);

      // Send video metadata early so UI can show title
      await send("metadata", { video });

      // Step 2: Transcript acquisition (fast path: YouTube timedtext captions)
      await send("progress", { step: 2, total: 4, message: "ğŸ“ ìë§‰(ìº¡ì…˜) í™•ì¸ ì¤‘â€¦" });
      await updateAssistant(`## ğŸ“º ${video.title ?? "YouTube ì˜ìƒ"}\n\nâ—â—â—‹â—‹ (2/4)\n\nğŸ“ ìë§‰(ìº¡ì…˜) í™•ì¸ ì¤‘â€¦`);

      let transcriptText = "";
      let transcriptLanguage = lang;
      let transcriptSource = "";
      let transcriptIsTruncated = false;
      let transcriptSegmentsCount = 0;

      let summaryMd = "";
      let outlineMd = "";
      let questionsMd = "";

      const timed = await fetchTimedTextTranscript(videoId, lang).catch(() => null);
      if (timed && typeof timed.textWithTimestamps === "string" && timed.textWithTimestamps.trim()) {
        transcriptText = timed.textWithTimestamps;
        transcriptLanguage = timed.language;
        transcriptSource = timed.isAutoGenerated ? "timedtext-asr" : "timedtext";
        transcriptIsTruncated = timed.isTruncated;
        transcriptSegmentsCount = timed.segmentsCount;

        // Step 3: Generate analysis from transcript text (much faster than video transcription)
        await send("progress", { step: 3, total: 4, message: "âš¡ï¸ ìë§‰ ê¸°ë°˜ìœ¼ë¡œ ìš”ì•½/ì•„ì›ƒë¼ì¸ ìƒì„± ì¤‘â€¦" });
        await updateAssistant(`## ğŸ“º ${video.title ?? "YouTube ì˜ìƒ"}\n\nâ—â—â—â—‹ (3/4)\n\nâš¡ï¸ ìë§‰ ê¸°ë°˜ìœ¼ë¡œ ìš”ì•½/ì•„ì›ƒë¼ì¸ ìƒì„± ì¤‘â€¦`);

        const analysisPrompt = [
          "You are an expert video analyst.",
          "",
          "You are given a YouTube transcript with timestamps. Use it to create a concise, accurate summary and outline.",
          "",
          "Return EXACTLY three sections in this order, each starting with its header line:",
          "### SUMMARY",
          "### OUTLINE",
          "### QUESTIONS",
          "",
          "Rules:",
          "- SUMMARY: 8â€“12 bullet points in Korean.",
          "- OUTLINE: bullet list of key moments. Each bullet MUST start with [MM:SS] and MUST be grounded in the transcript timestamps.",
          "- QUESTIONS: 5 follow-up questions in Korean.",
          "- Do NOT include a transcript in your response.",
          "- Output ONLY these sections; no extra text.",
          "",
          `Preferred language hint: ${lang}`,
          "",
          "Transcript:",
          transcriptText,
        ].join("\n");

        const analysisCombined = await geminiGenerateText({
          apiKey: geminiKey,
          model: geminiModel,
          contents: [{ role: "user", parts: [{ text: analysisPrompt }] }],
        });

        summaryMd = takeSection(analysisCombined, "SUMMARY");
        outlineMd = takeSection(analysisCombined, "OUTLINE");
        questionsMd = takeSection(analysisCombined, "QUESTIONS");
      } else {
        // Fallback: no captions â€” use Gemini video understanding (slower)
        transcriptSource = "gemini";

        await send("progress", { step: 2, total: 4, message: "ğŸ§ ìë§‰ ì—†ìŒ â†’ Geminië¡œ ì „ì‚¬/ë¶„ì„ ì¤‘â€¦ (ì‹œê°„ì´ ê±¸ë¦´ ìˆ˜ ìˆì–´ìš”)" });
        await updateAssistant(`## ğŸ“º ${video.title ?? "YouTube ì˜ìƒ"}\n\nâ—â—â—‹â—‹ (2/4)\n\nğŸ§ ìë§‰ ì—†ìŒ â†’ Geminië¡œ ì „ì‚¬/ë¶„ì„ ì¤‘â€¦ (ì‹œê°„ì´ ê±¸ë¦´ ìˆ˜ ìˆì–´ìš”)`);

        const prompt = [
          "You are an expert YouTube video analyzer and transcription engine.",
          "",
          "Return EXACTLY four sections in this order, each starting with its header line:",
          "### SUMMARY",
          "### OUTLINE",
          "### QUESTIONS",
          "### TRANSCRIPT",
          "",
          "Rules:",
          "- SUMMARY: 8â€“12 bullet points in Korean.",
          "- OUTLINE: bullet list of key moments. Each bullet MUST start with [MM:SS].",
          "- QUESTIONS: 5 follow-up questions in Korean.",
          "- TRANSCRIPT: FULL transcript of ALL spoken words. Each line MUST be: [MM:SS] <text>",
          "- Output ONLY these sections; no extra text.",
          "",
          `Preferred language hint: ${lang}`,
          "",
          "Important: If the video is long, still try to output as much transcript as possible in the required format.",
        ].join("\n");

        const combined = await geminiGenerateText({
          apiKey: geminiKey,
          model: geminiModel,
          contents: [
            {
              role: "user",
              parts: [{ file_data: { file_uri: video.url } }, { text: prompt }],
            },
          ],
        });

        // Step 3: Parsing results
        await send("progress", { step: 3, total: 4, message: "ğŸ“ ê²°ê³¼ ì •ë¦¬ ì¤‘â€¦" });
        await updateAssistant(`## ğŸ“º ${video.title ?? "YouTube ì˜ìƒ"}\n\nâ—â—â—â—‹ (3/4)\n\nğŸ“ ê²°ê³¼ ì •ë¦¬ ì¤‘â€¦`);

        summaryMd = takeSection(combined, "SUMMARY");
        outlineMd = takeSection(combined, "OUTLINE");
        questionsMd = takeSection(combined, "QUESTIONS");
        const transcriptRaw = takeSection(combined, "TRANSCRIPT");
        const transcriptSanitized = sanitizeTranscript(transcriptRaw);
        transcriptText = transcriptSanitized.text;
        transcriptIsTruncated = transcriptSanitized.isTruncated;
        transcriptSegmentsCount = transcriptSanitized.segmentsCount;
      }

      // Step 4: Saving to DB
      await send("progress", { step: 4, total: 4, message: "ğŸ’¾ DBì— ì €ì¥ ì¤‘â€¦" });
      await updateAssistant(`## ğŸ“º ${video.title ?? "YouTube ì˜ìƒ"}\n\nâ—â—â—â— (4/4)\n\nğŸ’¾ DBì— ì €ì¥ ì¤‘â€¦`);

      const { data: ctx, error: upsertError } = await supabase
        .from("video_contexts")
        .upsert(
          {
            user_id: user.id,
            session_id: body.sessionId,
            provider: "gemini",
            video_id: videoId,
            url: video.url,
            title: video.title,
            channel_title: video.channelTitle,
            description: video.description,
            transcript_language: transcriptLanguage,
            transcript_source: transcriptSource,
            transcript_text: transcriptText,
            summary_md: summaryMd,
            outline_md: outlineMd,
            questions_md: questionsMd,
          },
          { onConflict: "session_id,video_id" }
        )
        .select()
        .single();

      if (upsertError) throw new Error(upsertError.message);

      const assistantMarkdown = buildAnalysisMarkdown({
        video,
        summaryMd,
        outlineMd,
        questionsMd,
        transcriptSaved: Boolean(transcriptText),
        transcriptSource: transcriptSource || "unknown",
        transcriptTruncated: transcriptIsTruncated,
      });

      await updateAssistant(assistantMarkdown);

      // Final result
      await send("complete", {
        context: ctx,
        video,
        analysis: {
          markdown: assistantMarkdown,
          transcriptTruncated: transcriptIsTruncated,
          transcriptSegments: transcriptSegmentsCount,
        },
      });

      await writer.close();
    } catch (e) {
      const message = e instanceof Error ? e.message : "Unexpected error";
      try {
        await sendError(message);
      } catch {
        // Writer might already be closed
      }
    }
  })();

  return new Response(stream.readable, {
    headers: {
      "Content-Type": "text/event-stream",
      "Cache-Control": "no-cache",
      Connection: "keep-alive",
    },
  });
}
