import { z } from "zod";
import { requireUser } from "@/lib/api/auth";

export const runtime = "nodejs";

const QuerySchema = z.object({
  url: z.string().min(1).optional(),
  videoId: z.string().min(1).optional(),
  lang: z.string().optional(), // preferred language (e.g. "ko", "en")
});

type YouTubeVideo = {
  videoId: string;
  url: string;
  title: string | null;
  channelTitle: string | null;
  description: string | null;
  publishedAt: string | null;
  thumbnail: string | null;
  viewCount: number | null;
  duration: string | null;
};

type Transcript = {
  language: string;
  isAutoGenerated: boolean;
  isTruncated: boolean;
  segmentsCount: number;
  textWithTimestamps: string;
};

function getApiKey(): string | null {
  return process.env.YOUTUBE_DATA_API_KEY ?? process.env.YOUTUBE_API_KEY ?? null;
}

function extractYouTubeId(input: string): string | null {
  const text = input.trim();
  // watch?v=
  const m1 = text.match(/(?:youtube\.com\/watch\?[^#\s]*\bv=)([a-zA-Z0-9_-]{6,})/i);
  if (m1?.[1]) return m1[1];
  // youtu.be/
  const m2 = text.match(/youtu\.be\/([a-zA-Z0-9_-]{6,})/i);
  if (m2?.[1]) return m2[1];
  // shorts/
  const m3 = text.match(/youtube\.com\/shorts\/([a-zA-Z0-9_-]{6,})/i);
  if (m3?.[1]) return m3[1];
  return null;
}

function msToTimestamp(ms: number): string {
  const totalSec = Math.max(0, Math.floor(ms / 1000));
  const h = Math.floor(totalSec / 3600);
  const m = Math.floor((totalSec % 3600) / 60);
  const s = totalSec % 60;
  if (h > 0) return `${String(h).padStart(2, "0")}:${String(m).padStart(2, "0")}:${String(s).padStart(2, "0")}`;
  return `${String(m).padStart(2, "0")}:${String(s).padStart(2, "0")}`;
}

type RawYouTubeVideoItem = {
  id?: string;
  snippet?: {
    title?: string;
    channelTitle?: string;
    description?: string;
    publishedAt?: string;
    thumbnails?: {
      default?: { url?: string };
      medium?: { url?: string };
      high?: { url?: string };
      standard?: { url?: string };
      maxres?: { url?: string };
    };
  };
  statistics?: { viewCount?: string };
  contentDetails?: { duration?: string };
};

function parseVideo(item: RawYouTubeVideoItem, videoId: string): YouTubeVideo {
  const snippet = item.snippet ?? {};
  const thumbnails = snippet.thumbnails ?? {};
  const thumbCandidates = [
    thumbnails.maxres?.url,
    thumbnails.standard?.url,
    thumbnails.high?.url,
    thumbnails.medium?.url,
    thumbnails.default?.url,
  ].filter((v): v is string => typeof v === "string");

  const viewCountRaw = item.statistics?.viewCount;
  const viewCount = typeof viewCountRaw === "string" ? Number(viewCountRaw) : null;

  return {
    videoId,
    url: `https://www.youtube.com/watch?v=${encodeURIComponent(videoId)}`,
    title: typeof snippet.title === "string" ? snippet.title : null,
    channelTitle: typeof snippet.channelTitle === "string" ? snippet.channelTitle : null,
    description: typeof snippet.description === "string" ? snippet.description : null,
    publishedAt: typeof snippet.publishedAt === "string" ? snippet.publishedAt : null,
    thumbnail: thumbCandidates[0] ?? null,
    viewCount: Number.isFinite(viewCount) ? viewCount : null,
    duration: typeof item.contentDetails?.duration === "string" ? item.contentDetails.duration : null,
  };
}

async function fetchVideoMeta(apiKey: string, videoId: string): Promise<YouTubeVideo> {
  const url = new URL("https://www.googleapis.com/youtube/v3/videos");
  url.searchParams.set("part", "snippet,statistics,contentDetails");
  url.searchParams.set("id", videoId);
  url.searchParams.set("key", apiKey);

  const res = await fetch(url.toString(), { method: "GET" });
  const json = await res.json().catch(() => ({}));
  const item = Array.isArray(json?.items) ? (json.items[0] as RawYouTubeVideoItem | undefined) : undefined;

  if (!res.ok) {
    const message = typeof json?.error?.message === "string" ? json.error.message : `YouTube API error (${res.status})`;
    throw new Error(message);
  }

  return parseVideo(item ?? {}, videoId);
}

type Track = { lang: string; kind?: string; name?: string };

function parseTrackListXml(xml: string): Track[] {
  const tracks: Track[] = [];
  const re = /<track\b([^>]*)\/?>/gi;
  let m: RegExpExecArray | null;
  while ((m = re.exec(xml))) {
    const attrs = m[1] ?? "";
    const lang = attrs.match(/\blang_code="([^"]+)"/i)?.[1] ?? attrs.match(/\blang="([^"]+)"/i)?.[1];
    if (!lang) continue;
    const kind = attrs.match(/\bkind="([^"]+)"/i)?.[1];
    const name = attrs.match(/\bname="([^"]*)"/i)?.[1];
    tracks.push({ lang, kind, name });
  }
  return tracks;
}

function pickTrack(tracks: Track[], preferredLang?: string): Track | null {
  if (tracks.length === 0) return null;
  const pref = (preferredLang ?? "").trim().toLowerCase();
  const prefer = [pref, "ko", "en"].filter(Boolean);

  const find = (lang: string, auto: boolean) =>
    tracks.find((t) => t.lang.toLowerCase() === lang && (auto ? t.kind === "asr" : !t.kind));

  for (const lang of prefer) {
    const manual = find(lang, false);
    if (manual) return manual;
    const asr = find(lang, true);
    if (asr) return asr;
  }

  // Fallback: first manual, else first
  return tracks.find((t) => !t.kind) ?? tracks[0] ?? null;
}

type TimedTextJson3 = {
  events?: Array<{
    tStartMs?: number;
    dDurationMs?: number;
    segs?: Array<{ utf8?: string }>;
  }>;
};

async function fetchTimedTextTrackList(videoId: string): Promise<Track[]> {
  const url = new URL("https://www.youtube.com/api/timedtext");
  url.searchParams.set("type", "list");
  url.searchParams.set("v", videoId);
  const res = await fetch(url.toString(), { method: "GET" });
  if (!res.ok) return [];
  const xml = await res.text().catch(() => "");
  if (!xml) return [];
  return parseTrackListXml(xml);
}

async function fetchTranscript(videoId: string, preferredLang?: string): Promise<Transcript | null> {
  const tracks = await fetchTimedTextTrackList(videoId);
  const track = pickTrack(tracks, preferredLang);
  if (!track) return null;

  const url = new URL("https://www.youtube.com/api/timedtext");
  url.searchParams.set("fmt", "json3");
  url.searchParams.set("v", videoId);
  url.searchParams.set("lang", track.lang);
  if (track.kind === "asr") url.searchParams.set("kind", "asr");
  if (typeof track.name === "string" && track.name.length > 0) url.searchParams.set("name", track.name);

  const res = await fetch(url.toString(), { method: "GET" });
  if (!res.ok) return null;
  const json = (await res.json().catch(() => null)) as TimedTextJson3 | null;
  const events = Array.isArray(json?.events) ? json!.events! : [];

  const lines: string[] = [];
  let segmentsCount = 0;
  for (const ev of events) {
    const startMs = typeof ev.tStartMs === "number" ? ev.tStartMs : null;
    const segs = Array.isArray(ev.segs) ? ev.segs : [];
    const text = segs.map((s) => (typeof s.utf8 === "string" ? s.utf8 : "")).join("").replace(/\s+/g, " ").trim();
    if (!text) continue;
    if (startMs === null) continue;
    segmentsCount += 1;
    lines.push(`[${msToTimestamp(startMs)}] ${text}`);
  }

  const MAX_CHARS = 120_000;
  let textWithTimestamps = lines.join("\n");
  let isTruncated = false;
  if (textWithTimestamps.length > MAX_CHARS) {
    textWithTimestamps = textWithTimestamps.slice(0, MAX_CHARS);
    isTruncated = true;
  }

  return {
    language: track.lang,
    isAutoGenerated: track.kind === "asr",
    isTruncated,
    segmentsCount,
    textWithTimestamps,
  };
}

type CacheEntry = { fetchedAtMs: number; video: YouTubeVideo; transcript: Transcript | null };

function getCacheMap(): Record<string, CacheEntry | undefined> {
  const g = globalThis as unknown as { __llmkv_youtube_context_cache?: Record<string, CacheEntry | undefined> };
  if (!g.__llmkv_youtube_context_cache) g.__llmkv_youtube_context_cache = {};
  return g.__llmkv_youtube_context_cache;
}

export async function GET(request: Request) {
  try {
    await requireUser(request);

    const apiKey = getApiKey();
    if (!apiKey) {
      return Response.json(
        { error: "Missing YouTube API key. Set server env var YOUTUBE_DATA_API_KEY." },
        { status: 500 }
      );
    }

    const url = new URL(request.url);
    const parsed = QuerySchema.parse({
      url: url.searchParams.get("url") ?? undefined,
      videoId: url.searchParams.get("videoId") ?? undefined,
      lang: url.searchParams.get("lang") ?? undefined,
    });

    const videoId = parsed.videoId ?? (parsed.url ? extractYouTubeId(parsed.url) : null);
    if (!videoId) {
      return Response.json({ error: "Invalid or missing YouTube URL/videoId" }, { status: 400 });
    }

    const cacheKey = `${videoId}:${(parsed.lang ?? "").trim().toLowerCase() || "auto"}`;
    const cache = getCacheMap();
    const ttlMs = 10 * 60 * 1000;
    const now = Date.now();
    const existing = cache[cacheKey];
    if (existing && now - existing.fetchedAtMs < ttlMs) {
      return Response.json({
        video: existing.video,
        transcript: existing.transcript,
        meta: { cached: true, fetchedAt: new Date(existing.fetchedAtMs).toISOString(), ttlSeconds: Math.floor(ttlMs / 1000) },
      });
    }

    const [video, transcript] = await Promise.all([
      fetchVideoMeta(apiKey, videoId),
      fetchTranscript(videoId, parsed.lang),
    ]);

    cache[cacheKey] = { fetchedAtMs: now, video, transcript };

    return Response.json({
      video,
      transcript,
      meta: { cached: false, fetchedAt: new Date(now).toISOString(), ttlSeconds: Math.floor(ttlMs / 1000) },
    });
  } catch (e) {
    if (e instanceof Response) return e;
    if (e instanceof z.ZodError) return Response.json({ error: e.message }, { status: 400 });
    const message = e instanceof Error ? e.message : "Unexpected error";
    return Response.json({ error: message }, { status: 500 });
  }
}


